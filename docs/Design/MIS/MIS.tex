\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}
\usepackage{mathtools}
\usepackage{amsmath}


\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{Elizabeth Hofer}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
11.19.2020 & 1.0 & Initial Release\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See SRS Documentation at \url{https://github.com/liziscool/cas741_project/blob/master/docs/SRS/SRS.pdf}
\wss{Also add any additional symbols, abbreviations or acronyms}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\progname{}, a program to compute the time-frequency analysis of a 1 dimensional signal.

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/liziscool/cas741_project}.  \wss{provide the url for your repo}

\section{Notation}

\wss{You should describe your notation.  You can use what is below as
  a starting point.}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
complex & $\mathbb{C}$ & a number with a real part $a$ and an imaginary part $b$ s.t. $a + bi$ where $i$ is the imaginary number\\
\bottomrule
\end{tabular} 
\end{center}

\noindent

The specification of \progname{} uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings
are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname{} uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2}\\
\midrule

{Hardware-Hiding Module} & ~ \\
\midrule

\multirow{7}{0.3\textwidth}{Behaviour-Hiding Module} &  Input Parameter Module\\
& Specification Param Module \\
& Read Data Module\\
& Boundary Configuration Module \\
& STFT Module\\
& Wavelet Module\\
& Output Verification Module\\
& Output Module\\
& Compute Transform Module \\ 
& Control Module\\
\midrule

\multirow{3}{0.3\textwidth}{Software Decision Module} & { Zero-Pad Module}\\
& Matrix Data Structure Module\\ 
& Plotting Module\\
& Fast Fourier Transform Module\\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage
~\newpage

\section{MIS of Control Module} \label{ControlModule} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}

main

\subsection{Uses}

Compute Transform Module \ref{CompTransformModule}, Output Module \ref{OutputModule}, Output Verification Module, Plotting Module \ref{PlottingModule}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
main & $argc: \mathbb{N}$, $<argv_1, \dots, argv_{argc}>$ s.t. $argv_n : string$ & - & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.
\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}
None.
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
\begin{itemize}
\item User enters correct inputs for calculation that is expected.
\item User enters inputs in correct format.
\end{itemize}
\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent main():
\begin{itemize}

\item transition: Controls the entire program, transition through the program as follows:
\begin{enumerate}
\item Sets \texttt{param} from command line arguments \texttt{set\_inputs()}.
\item Calls compute transform module with \texttt{comp\_transform()}.
\item Plots output with \texttt{plot\_matrix()}
\end{enumerate}
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}
None. 
\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}


\newpage

\section{MIS of Specification Parameter Module} \label{SpecParamModule} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
spec\_param
\wss{Short name for the module}

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{center}
\begin{tabular}{p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{Type} \\
\hline \\
MIN\_FREQ & $\mathbb{R}$\\
MAX\_FREQ & $\mathbb{R}$\\
MIN\_SIG\_LEN & $\mathbb{N}$\\
MAX\_SIG\_LEN & $\mathbb{N}$\\
STEP\_SIZE & $\mathbb{N}$\\
WIN\_SIZE & $\mathbb{N}$\\
\hline
\end{tabular}
\end{center}


\subsubsection{Exported Access Programs}
None.

\subsection{Semantics}

\subsubsection{State Variables}
None.
\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}
None.
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
None.
\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}
None.

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}
None.
\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}
\subsection{Considerations}
This module basically just holds all of the constants.

\newpage

\newpage

\section{MIS of Input Param Module} \label{InputParamModule} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
input\_param
\wss{Short name for the module}

\subsection{Uses}
Specification Param Module \ref{SpecParamModule}, Hardware Hiding Module
\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{3cm} p{2cm} p{3cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
set\_input & $argc: \mathbb{N}$, $<argv_1, \dots, argv_{argc}>$ s.t. $argv_n : string$& - & bad\_arguments, bad\_min\_time, bad\_max\_time, bad\_time\_range, bad\_min\_freq, bad\_max\_freq, bad\_freq\_range , bad\_transform\_type \\
param.N & - &$\mathbb{N}$ & \\
$f_1$ &  - &$\mathbb{R}$ & \\
$f_2$ & - & $\mathbb{R}$ &  \\
$n_1$ & - & $\mathbb{R}$ & \\
$n_2$ & - & $\mathbb{R}$ & \\
transform\_type & - & $\{`W', `S'\}$ &  \\
param.time\_res & - & $\mathbb{N} $&\\
param.freq\_res & - &$\mathbb{N}$ & \\
param.sig\_file & - & string & \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.
\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}
None.
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
While there will be measures in place to check that the input values comply with the ability of the program, some additional assumptions are listed below
\begin{enumerate}
\item The user inputs the correct file path.
\item The bounds are appropriate for the signal.
\item The input parameters must be set (initialized) before they are accessed. 
\end{enumerate}
\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

set\_input():
\begin{itemize}
\item output: None.
\item exception: exc:=
\[ \begin{cases} 
 bad\_arguments & \text{if any of the arguments are incorrectly flagged (i.e. using a flag that doesnt exist}\\ 
 bad\_min\_time & \text{if } n_1 \geq n_2 \\
 bad\_max\_time & \text{if } n_2>N \\ 
 bad\_time\_range & \text{if } (n_2 - n_1)> MAX\_SIG\_LEN \text{ or } (n_2 - n_1)<MIN\_SIG\_LEN \\
 bad\_min\_freq  & \text{if } f_1 < MIN\_FREQ \\
 bad\_max\_freq  & \text{if } f_2 < MAX\_FREQ \\
 bad\_freq\_range &  \text{if } (f_2 - f_1)> MAX\_FREQ\_RZANGE \text{ or } (f_2 - f_1)<MIN\_FREQ\_RANGE\\
  bad\_transform\_type &  \text{if T is not `W' or `S'}
   \end{cases}
\]
\end{itemize}


param.N :
\begin{itemize}
\item output: $out := N$
\item exception: none
\end{itemize}

param.f1 :
\begin{itemize}
\item output: $out := f_1$
\item exception: none
\end{itemize}

param.f2 :
\begin{itemize}
\item output: $out := f_2$
\item exception: none
\end{itemize}

param.n1 :
\begin{itemize}
\item output: $out := n_1$
\item exception: none
\end{itemize}

param.n2 :
\begin{itemize}
\item output: $out := n_2$
\item exception: none
\end{itemize}

param.time\_div :
\begin{itemize}
\item output: $out := time\_div$
\item exception: none
\end{itemize}

param.freq\_div :
\begin{itemize}
\item output: $out := freq\_div$
\item exception: none
\end{itemize}

param.time\_res :
\begin{itemize}
\item output: $out := time\_res$
\item exception: none
\end{itemize}

param.freq\_res :
\begin{itemize}
\item output: $out := freq\_res$
\item exception: none
\end{itemize}

param.sig\_filename :
\begin{itemize}
\item output: $out := sig\_filename$
\item exception: none
\end{itemize}


\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}
None.
\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}
 

\section{MIS of Read Data Module} \label{ReadDataModule} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
read\_data
\wss{Short name for the module}

\subsection{Uses}
Input Param Module \ref{InputParamModule}
\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{2cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
read\_sig & sig\_filename:string  & $<x_1, \dots, x_N>$ $x_n : \mathbb{R}$ & bad\_path, empty\_file, file\_wrong\_format \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.
\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}
None.
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
\begin{enumerate}
\item File should be in correct format.
\end{enumerate}
\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent read\_sig():
\begin{itemize}
\item output: out := $<x_1, \dots, x_N>$
\item exception: exc := \[ \begin{cases} 
bad\_file & \text{if the file or a directory on the path does not exist}\\ empty\_file & \text{if the file has no data in it}\\
file\_format\_wrong & \text{if data in the folder is not in }\mathbb{R} \text{ or uses incorrect delimter}
   \end{cases}
\]
\end{itemize}
\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}
None.
\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}


\section{MIS of Boundary Configuration Module} \label{BoundryConfigModule} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
bound\_config
\wss{Short name for the module}

\subsection{Uses}
Specification Param Module \ref{SpecParamModule}
\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{5cm} p{2cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
calc\_freq\_res & $f_1 : \mathbb{R}$,$f_2 : \mathbb{R}$, win\_size $:\mathbb{N} $ & $ \mathbb{R} $ & - \\
calc\_time\_res & $n_1 : \mathbb{N}$,$n_2 : \mathbb{R}$, step\_size $:\mathbb{N} $ & $\mathbb{N}$ & - \\

\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.
\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}
None.
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
None.
\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent calc\_freq\_res():
\begin{itemize}
\item output: out := $ (f_2 - f_1) * win\_size$
\end{itemize}

\noindent calc\_time\_res():
\begin{itemize}
\item output: out := $ \frac{(n_2 - n_1)}{\frac{win\_size}{step\_size}}  $
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}
None.
\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}
  
\subsection{Considerations}
At the time this document was written, the writer is not totally confident in the methods to calculate time\_res or freq\_res. The equations provided above are sufficient to communicate the point, but in execution it may be more complicated, and at that time this section of the document will be updated to reflect that. 

\section{MIS of STFT Module} \label{STFT Module} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
STFT
\wss{Short name for the module}

\subsection{Uses}
FFT Module, Boundary Configuration Module \ref{BoundryConfigModule}  Matrix Data Structure Module \ref{MatrixDataStructureModule}
\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
comp\_stft & $< x_1, \dots, x_N>$ where $x_n:\mathbb{R}$, $N:\mathbb{N} $, time\_res$:\mathbb{N}$, freq\_res$:\mathbb{N}$ & $< X_{0,0},X_{0,1},\dots,X_{1,0}, X_{1,1},\dots,X_{I,J}>$ where $ x_{i,j}:\mathbb{C}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.
\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}
None.
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
None.
\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent comp\_stft():
\begin{itemize}
\item output: out := $< X_{0,0}, X_{0,1}, \dots, X_{1,0}, X_{1,1}, \dots, X_{I,J}>$ where
\\ $ X_{i,j} : \mathbb{C}$ s.t.\\
\begin{equation}
X(i, j) = \displaystyle \sum_{i=0}^{WIN\_SIZE} x_i w_i e^{-\hat{i} \omega j} 
\end{equation}  \\
and $I[0,time\_res]$ and $J[0,freq\_res]$ and $\hat{i}$ is the imaginary number.
\item This routine will utilize the fast Fourier transform.
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}
\noindent window\_function():
\begin{itemize}
\item output: out := $< w_0, \dots, w_{WIN\_SIZE}>$ where 
\begin{equation} 
w_n =(\sin{\frac{\pi * n}{WIN\_SIZE}})^2
\end{equation}

\end{itemize}
\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}
  

\section{MIS of Wavelet} \label{WaveletModule} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
wavelet
\wss{Short name for the module}

\subsection{Uses}
FFT Module, Boundrey Configuration Module \ref{BoundryConfigModule}, Matrix Data Structure Module \ref{MatrixDataStructureModule}
\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2.5cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
comp\_waveletT & $<x_1,\dots,x_N>$ where $ x_n:\mathbb{R}$, $N:\mathbb{N}$, time\_res$:\mathbb{N}$, freq\_res $:\mathbb{N}$ & $<X_{0,0},X_{0,1},\dots, X_{1,0},X_{1,1},\dots, X_{I,J}>$ where $ x_{i,j}:\mathbb{C}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.
\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}
None.
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
None.
\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent comp\_waveletT():
\begin{itemize}
\item output: out := $<X_{0,0},X_{0,1},\dots, X_{1,0},X_{1,1},\dots, X_{I,J}>$ s.t. 
\begin{equation}
X(a,b) = \frac{1}{\sqrt{a}} \Sigma_{n = 0}^{wav\_scale\_a} \Psi_{a,b,n} x_n 
\end{equation}
where $\Psi_{a,b,n}$ represents the wavelet scaled by $a$ and shifted by $b$.
\end{itemize}


\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}

\noindent wavelet\_function():
\begin{itemize}
\item output: out := $< w_0, \dots, w_{wav\_scale\_a}>$ where 
\begin{equation}
w_n = c_\sigma \pi^{-\frac{1}{4} e^{- \frac{1}{2} t}} (e^{i \sigma n} - \kappa_\sigma)
\end{equation}
and where $ \kappa_\sigma = e^{1 \frac{1}{2} \sigma^2}$  and  $c_\sigma = (1 + e^{- \sigma^2} - 2 e^{- \frac{3}{4} \sigma^2})^{\frac{1}{2}}$, a.k.a. a Morlet Wavelet.
\end{itemize}

\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}
  
\section{MIS of Output Verification Module} \label{Module} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
output\_verify
\wss{Short name for the module}

\subsection{Uses}
Matrix Data Module 
\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
verify\_output & $<X_{0,0},X_{0,1},\dots, X_{1,0},X_{1,1},\dots, X_{I,J}>$ where $ x_{i,j}:\mathbb{R}$ & $b: \mathbb{B}$ &  -\\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.
\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}
None.
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
None.
\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent verify\_output():
\begin{itemize}
\item output: out := \[ \begin{cases} 
      T & \text{if } \text{transform passes verification} \\
      F & \text{if } \text{transform fails verification} 
   \end{cases}
\]
To pass the verification the output matrix must pass the following conditions: 
\begin{equation}
\Sigma_{j=0}^{freq\_res} X_{i,j} \leq \Sigma x_n  
\end{equation}
where $\Sigma x_n$ and corresponds to the portion of the signal represented by $i$ in $X_{i,j}$.

\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}
None.
\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}

\section{MIS of Output Module} \label{OutputModule} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
output
\wss{Short name for the module}

\subsection{Uses}
Hardware Hiding Module 
\subsection{Syntax}

\subsubsection{Exported Constants}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
get\_output & - & $<X_{0,0},X_{0,1},\dots, X_{1,0},X_{1,1},\dots, X_{I,J}>$ where $ x_{i,j}:\mathbb{R}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.
\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}
None.
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
\begin{enumerate}
\item The user requires the memory location of the output matrix, as in it does not need to be written to any external file.
\end{enumerate}
\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent get\_output():
\begin{itemize}
\item output: out := $<X_{0,0},X_{0,1},\dots, X_{1,0},X_{1,1},\dots, X_{I,J}>$ where $ x_{i,j}:\mathbb{R}$\\
where $X$ is the time frequency representation of the data as calculated by \progname{}.

\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}
None.
\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}
  
\section{MIS of Compute Transform} \label{CompTransformModule} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
comp\_transform
\wss{Short name for the module}

\subsection{Uses}
Read Data Module \ref{ReadDataModule}, Wavelet Module \ref{WaveletModule}, STFT Module \ref{STFT Module}, Zero Pad Module \ref{Zero Pad Module}, Matrix Data Structure Module \ref{MatrixDataStructureModule}
\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{3cm} p{4cm} p{5cm} p{1cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
comp\_transform & $<x_1,\dots,x_N>$ where $ x_n:\mathbb{R}$, $N:\mathbb{N}, f_1:
\mathbb{R}, f_2 : \mathbb{R}$, $T: \{`W',`S'\}$ & $<X_{0,0},X_{0,1},\dots, X_{1,0},X_{1,1},\dots, X_{I,J}>$ where $ x_{i,j}:\mathbb{R}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.
\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}
None.
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
None.
\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent comp\_transform():
\begin{itemize}
\item output: $<X_{0,0},X_{0,1},\dots, X_{1,0},X_{1,1},\dots, X_{I,J}>$ where $ x_{i,j}:\mathbb{R}$
\end{itemize}
Such that $X$ is calculated in the following way:
\begin{enumerate}
\item The input signal is read using \texttt{read\_data} \ref{ReadDataModule} using the parameters specified by the Input Parameter Module \ref{InputParamModule}.
\item The signal is zero-padded using Zero Pad Module.
\item Some computations are done regarding the boundary configuration using \texttt{calc\_freq\_res} and \texttt{calc\_time\_res} from \ref{BoundryConfigModule} which are needed for the following step.
\item The signal is transformed using ether \texttt{comp\_waveletT} if $T = `W'$ or \texttt{comp\_STFT} if $T = `T'$ 
\item The matrix output from the transforms are complex, to convert them to a real power values the matrix is $X$ is computed from as followed:\\
$X_{i,j} = \sqrt{X_{\mathbb{C}}.real^2 + _{\mathbb{C}}.im^2}$\\
Where $X_\mathbb{C}.real$ is the real part of the transform and $X_\mathbb{C}.im$ is the imaginary part.

\end{enumerate}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}
None.
\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}
  
\subsection{Considerations}
The Zero-Pad Module extends the size of the signal $x$ by 2 times the window size $WIN\_SIZE$, however, this doesn't affect the size of the output transform matrix.

\section{MIS of Zero Pad Module} \label{Zero Pad Module} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
zero\_pad
\wss{Short name for the module}

\subsection{Uses}
None.
\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{5cm} p{1cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
zero\_pad\_sig & $<x_1,\dots,x_N>$ where $ x_n:\mathbb{R}$, $N:\mathbb{N}$, $WIN\_SIZE$ & $<x_1,\dots,x_{N+2 WIN\_SIZE}>$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.
\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}
None.
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
None.
\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent zero\_pad\_sig():
\begin{itemize}
\item output: $<x_1,\dots,x_{N+2 WIN\_SIZE}>$ such that $x_n = 0$ from $n[0, WIN\_SIZE]$, $x_{n + WIN\_SIZE} = \hat{x}_n$ from $n[0, N]$ where $\hat{x}$ is the original signal and $N$ is the length of the original signal.
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}
None.
\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}
  
\section{MIS of Matrix Data Structure Module} \label{MatrixDataStructureModule} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
mat
\wss{Short name for the module}

\subsection{Uses}
None.
\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{1cm} p{3cm} p{6cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
init & $X:\mathbb{N}$, $Y:\mathbb{N}$ & $<X_{0,0},X_{0,1},\dots, X_{1,0},X_{1,1},\dots, X_{X,Y}>$ where $ x_{x,y}:NULL$ & - \\
m & $x:\mathbb{N}, y:\mathbb{N}$ & $m:\mathbb{R}$ & - \\
\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.
\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}
None.
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
None.
\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent mat.init():
\begin{itemize}
\item output: $<X_{0,0},X_{0,1},\dots, X_{1,0},X_{1,1},\dots, X_{X,Y}>$ \\
Where $X_{x,y}$ is null but it is large able to hold type $\mathbb{R}$.
\end{itemize}

\noindent mat.m():
\begin{itemize}
\item output: $m:\mathbb{R}$\\
$m$ is the data in the matrix at the specified index.
\end{itemize}

\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}
None.
\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}
  
  
  \section{MIS of Plotting Module} \label{PlottingModule} \wss{Use labels for
  cross-referencing}

\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}

\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}

\subsection{Module}
plot
\wss{Short name for the module}

\subsection{Uses}
None.
\subsection{Syntax}

\subsubsection{Exported Constants}
None.
\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\hline
plot\_matrix & $<X_{0,0},X_{0,1},\dots, X_{1,0},X_{1,1},\dots, X_{X,Y}>$ where $ x_{x,y}:\mathbb{R}$   & $b:\mathbb{B}$ & bad\_path \\

\hline
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.
\wss{Not all modules will have state variables.  State variables give the module
  a memory.}

\subsubsection{Environment Variables}
None.
\wss{This section is not necessary for all modules.  Its purpose is to capture
  when the module has external interaction with the environment, such as for a
  device driver, screen interface, keyboard, file, etc.}

\subsubsection{Assumptions}
None.
\wss{Try to minimize assumptions and anticipate programmer errors via
  exceptions, but for practical purposes assumptions are sometimes appropriate.}

\subsubsection{Access Routine Semantics}

\noindent plot\_matrix():
\begin{itemize}
\item output: out:= \[ \begin{cases} 
      F & \text{if output file was not created sucessfully}\\
	 T & \text{if output file was created sucessfully}\\
   \end{cases}
\]\\
\item exception: exc:= bad\_path if out file was not written successfully.
\end{itemize}
\wss{A module without environment variables or state variables is unlikely to
  have a state transition.  In this case a state transition can only occur if
  the module is changing the state of another module.}

\wss{Modules rarely have both a transition and an output.  In most cases you
  will have one or the other.}

\subsubsection{Local Functions}
\begin{center}
\begin{tabular}{p{2cm} p{3cm} p{3cm} p{4cm}}
\hline
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Description } \\
\hline
calc\_colour & $x:\mathbb{R}$ & $R,B,G:\mathbb{R}$ & converts the matrix value into corresponding R,G,B values for heat map\\

\hline
\end{tabular}
\end{center}
\wss{As appropriate} \wss{These functions are for the purpose of specification.
  They are not necessarily something that is going to be implemented
  explicitly.  Even if they are implemented, they are not exported; they only
  have local scope.}
  

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\end{document}